<!DOCTYPE html>
<html lang="es">
<head>
	<meta charset="UTF-10">
	
	<link rel="stylesheet" type="text/css" href="css/normalize.css">
	<link rel="stylesheet" type="text/css" href="css/estilos.css">
	
	
</head>
<body>



		<header>
			<img src="img/HEADER.jpg">
			<a href="http://www.reliablecounter.com" target="_blank"><img src="http://www.reliablecounter.com/count.php?page=16101117&digit=style/plain/13/&reloads=0" alt="" title="" border="0"></a><br /><a href="http://cuerpoaldente.com" target="_blank" style="font-family: Geneva, Arial; font-size: 9px; color: #330010; text-decoration: none;"></a>
		</header>

		<nav>
			<ul>
				<li>
					<a href="index.html">Inicio</a>
				</li>
				<li>
					<a href="contenido.html">Contenido</a>
				</li>
				<li>					
					<a href="enlaces.html">Enlaces de Contenido</a>
				</li>
				<li>
					<a href="multimedia.html">Multimedia</a>
				</li>
				<li>
					<a href="autor.html">Autor</a>
				</li>
			</ul>
            
           
    </header>
		</nav>
		<section id="contenido">
        
        
		  <article class="Intro">
		   METODOS DE ORDENAMIENTO 
			
<p>Debido a que las estructuras de datos son utilizadas para almacenar información, para poder recuperar esa información de manera eficiente es deseable que aquella esté ordenada. Existen varios métodos para ordenar las diferentes estructuras de datos básicas.<p>
<p>En general los métodos de ordenamiento no son utilizados con frecuencia, en algunos casos sólo una vez. Hay métodos muy simples de implementar que son útiles en los casos en dónde el número de elementos a ordenar no es muy grande (ej, menos de 500 elementos). Por otro lado hay métodos sofisticados, más difíciles de implementar pero que son más eficientes en cuestión de tiempo de ejecución.<p>
<p>Los métodos sencillos por lo general requieren de aproximadamente n x n pasos para ordenar n elementos.<p>
<p>Los métodos simples son: insertion sort (o por inserción directa) selection sort, bubble sort, y shellsort, en dónde el último es una extensón al insertion sort, siendo más rápido. Los métodos más complejos son el quick-sort, el heap sort, radix y address-calculation sort. El ordenar un grupo de datos significa mover los datos o sus referencias para que queden en una secuencia tal que represente un orden, el cual puede ser numérico, alfabético o incluso alfanumérico, ascendente o descendente.<p>
<p>Se ha dicho que el ordenamiento puede efectuarse moviendo los registros con las claves. El mover un registo completo implica un costo, el cual se incrementa conforme sea mayor el tamaño del registro. Es por ello que es deseable evitar al máximo el movimiento de los registros. Una alternativa es el crear una tabla de referencias a los registros y mover las referencias y no los datos. A continuación se mostrarán los métodos de ordenamiento empezando por el más sencillo y avanzando hacia los mas sofisticados <p>
<p>La eficiencia de los algoritmos se mide por el número de comparaciones e intercambios que tienen que hacer, es decir, se toma n como el número de elementos que tiene el arreglo a ordenar y se dice que un algoritmo realiza O(n2) comparaciones cuando compara n veces los n elementos, n x n = n2. <p>
<p>ORDENAMIENTO DE BURBUJA<p>
<p>_______________________<p>
<p>La Ordenación de burbuja (Bubble Sort en inglés) es un sencillo algoritmo de ordenamiento. Funciona revisando cada elemento de la lista que va a ser ordenada con el siguiente, intercambiándolos de posición si están en el orden equivocado. Es necesario revisar varias veces toda la lista hasta que no se necesiten más intercambios, lo cual significa que la lista está ordenada. Este algoritmo obtiene su nombre de la forma con la que suben por la lista los elementos durante los intercambios, como si fueran pequeñas "burbujas". También es conocido como el método del intercambio directo. Dado que solo usa comparaciones para operar elementos, se lo considera un algoritmo de comparación, siendo el más sencillo de implementar.<p>
<p>burbuja <p>
<p>#include<stdio.h> <p>
<p>#include<conio.h> <p>
<p>int a[3]={3,2,1}; <p>
<p>int i,j,aux,n=3; <p>
<p>void main(){ <p>
<p>clrscr(); <p>
<p>for(i=0;i<=n;i++){ <p>
<p>for(j=0;j<n-1;j++){ <p>
<p>if(a[j]>a[j+1]){ <p>
<p>aux=a[j]; <p>
<p>a[j]=a[j+1]; <p>
<p>a[j+1]=aux; <p>
<p>} <p>
<p>} <p>
<p>}<p> 
<p>for(i=0;i<3;i++) <p>
<p>{ <p>
<p>printf("%d",a); <p>
<p>}<p> 
<p>getch(); <p>
<p>}<p> 

<p> ORDENAMIENTO SHELL<p> 
<p> El ordenamiento Shell (Shell sort en inglés) es un algoritmo de ordenamiento. El método se denomina Shell en honor de su inventor Donald Shell. Su implementación original, requiere O(n2) comparaciones e intercambios en el peor caso. Un cambio menor presentado en el libro de V. Pratt produce una implementación con un rendimiento de O(n log2 n) en el peor caso. Esto es mejor que las O(n2) comparaciones requeridas por algoritmos simples pero peor que el óptimo O(n log n). Aunque es fácil desarrollar un sentido intuitivo de cómo funciona este algoritmo, es muy difícil analizar su tiempo de ejecución. El algoritmo Shell sort mejora el ordenamiento por inserción comparando elementos separados por un espacio de varias posiciones. Esto permite que un elemento haga "pasos más grandes" hacia su posición esperada. Los pasos múltiples sobre los datos se hacen con tamaños de espacio cada vez más pequeños. El último paso del Shell sort es un simple ordenamiento por inserción, pero para entonces, ya está garantizado que los datos del vector están casi ordenados.  <p> 
<p> shell <p> 
<p> #include<stdio.h> <p> 
<p> #include<conio.h> <p> 
<p> int a[5]; <p> 
<p> int n=5; <p> 
<p> void main() <p> 
<p> { <p> 
<p> int inter=(n/2),i=0,j=0,k=0,aux; <p> 
<p> clrscr(); <p> 
<p> for (i=0; i<5; i++) <p> 
<p> { <p> 
<p> printf("INSERTA UN VALOR DEL INDICE %d", i); <p> 
<p> scanf("%d",& a); <p> 
<p> } <p> 
<p> while(inter>0){ <p> 
<p> for(i=inter;i<n;i++) <p> 
<p> { <p> 
<p> j=i-inter; <p> 
<p> while(j>=0) { <p> 
<p> k=j+inter; <p> 
<p> if(a[j]<=a[k]){ <p> 
<p> j--; <p> 
<p> } <p> 
<p> else{ <p> 
<p> aux=a[j]; <p> 
<p> a[j]=a[k]; <p> 
<p> a[k]=aux; <p> 
<p> j=j-inter; <p> 
<p> } <p> 
<p> } <p> 
<p> } <p> 

<p> inter=inter/2; <p> 
<p> } <p> 
<p> for(i=0;i<5;i++) <p> 
<p> { <p> 
<p> printf("%d n",a); <p> 
<p> getch(); <p> 
<p> } <p> 
<p> }  <p> 

<p> ORDENAMIENTO POR INSERCION  <p> 
<p> __________________________<p> 

<p> El ordenamiento por inserción (insertion sort en inglés) es una manera muy natural de ordenar para un ser humano, y puede usarse fácilmente para ordenar un mazo de cartas numeradas en forma arbitraria. Requiere O(n²) operaciones para ordenar una lista de n elementos.<p> 

<p> Inicialmente se tiene un solo elemento, que obviamente es un conjunto ordenado. Después, cuando hay k elementos ordenados de menor a mayor, se toma el elemento k+1 y se compara con todos los elementos ya ordenados, deteniéndose cuando se encuentra un elemento menor (todos los elementos mayores han sido desplazados una posición a la derecha) o cuando ya no se encuentran elementos (todos los elementos fueron desplazados y este es el más pequeño). En este punto se inserta el elemento k+1 debiendo desplazarse los demás elementos.<p> 

<p> iinserccion <p> 
<p> #include<stdio.h> <p> 
<p> #include<conio.h> <p> 
<p> int a[4]={4,1,7,2}; <p> 
<p> int n=4; <p> 
<p> int i,j,aux; <p> 
<p> void main(){ <p> 
<p> clrscr(); <p> 
<p> for(i=1;i<n;i++) <p> 
<p> { <p> 
<p> j=i; <p> 
<p> aux=a; <p> 
<p> while(j>0 && aux<a[j-1]) <p> 
<p> { <p> 
<p> a[j]=a[j-1]; <p> 
<p> j--; <p> 
<p> } <p> 
<p> a[j]=aux; <p> 
<p> } <p> 
<p> for(i=0;i<4;i++) <p> 
<p> { <p> 
<p> printf("%d",a); <p> 
<p> } <p> 
<p> getch(); <p> 
<p> } <p> 

 <p> ORDENAMIENTO POR SELECCION  <p> 
<p> El ordenamiento por selección (Selection Sort en inglés) es un algoritmo de ordenamiento que requiere O operaciones para ordenar una lista de n elementos.<p> 
<p> Su funcionamiento es el siguiente:<p> 


<p> •	Buscar el mínimo elemento de la lista<p> 
<p> •	Intercambiarlo con el primero<p> 
<p> •	Buscar el mínimo en el resto de la lista<p> 
<p> •	Intercambiarlo con el segundo<p> 
<p> Y en general:<p> 


<p> •	Buscar el mínimo elemento entre una posición i y el final de la lista<p> 
<p> •	Intercambiar el mínimo con el elemento de la posición i<p> 
<p> De esta manera se puede escribir el siguiente pseudocódigo para ordenar una lista de n elementos indexados desde el 1:<p> 



<p> para i=1 hasta n-1<p> 
    <p> minimo = i;<p> 
    <p> para j=i+1 hasta n<p> 
        <p> si lista[j] < lista[minimo] entonces<p> 
            <p> minimo = j /* (!) */<p> 
        <p> fin si<p> 
    <p> fin para<p> 
    <p> intercambiar(lista[i], lista[minimo])<p> 
<p> fin para <p> 
 
 
 

 
<p> seleccion <p> 
<p> #include<stdio.h> <p> 
<p> #include<conio.h> <p> 
<p> int x[4]={1,4,8,6}; <p> 
<p> int n=4,j=0,i=0; <p> 
<p> int temp=0,minimo=0; <p> 
<p> void main(){ <p> 

<p> clrscr(); <p> 
<p> for(i=0;i<n-1;i++) <p> 
<p> { <p> 
<p> minimo=i; <p> 
<p> for(j=i+1;j<n;j++) <p> 
<p> { <p> 
<p> f(x[minimo] > x[j]) <p> 
<p> { <p> 
<p> minimo=j; <p> 
<p> }<p>  
<p> } <p> 
<p> temp=x[minimo]; <p> 
<p> x[minimo]=x; <p> 
<p> x=temp; <p> 
<p> } <p> 
<p> for(i=0;i<n;i++) <p> 
<p> { <p> 
<p> printf("%d",x); <p> 
<p> } <p> 
<p> getch(); <p> 
<p> }<p> 
<p> EJERCICIOS METODO DE ORDENAMIENTO EJERCICIO 01<p> 

<p> #include <stdio.h><p> 
<p> #define SIZE 7<p> 
<p> void main(void) {<p> 
  <p> int vector[SIZE];<p> 
  <p> int j, i, temp;<p> 
  <p> printf("Introduce los %d valores para ordenar:\n", SIZE);<p> 
  <p> for(i=0; i<SIZE; i++) {<p> 
     <p> printf("%d: ", i+1);<p> 
<p>      scanf("%d", &vector[i]);<p> 
     <p> printf("\n");<p> 
  <p> }<p> 
  <p> /* se aplica el algoritmo de la burbuja */<p> 
  <p> for(i=0; i<(SIZE-1); i++) {<p> 
     <p> for (j=i+1; j<SIZE; j++) {<p> 
        <p> if(vector[j]<vector[i]) {<p> 
            <p> temp=vector[j];<p> 
            <p> vector[j]=vector[i];<p> 
            <p> vector[i]=temp;<p> 
        <p> }<p> 
     <p> }<p> 
  <p> }<p> 
  <p> printf("El vector ordenado es:\n");<p> 
  <p> for(i=0; i<SIZE ; i++) {<p> 
     <p> printf("%d ", vector[i]);<p> 
  <p> }<p> 
  <p> printf("\n");<p> 
<p> }<p> 
 
<p> EJERCIO 02<p> 
 
<p> #include <stdio.h><p> 

<p> #include <stdlib.h><p> 

<p> #include <string.h><p> 
 

<p> void OrdenaBurbuja (float v[], int n)<p> 


<p> {<p> 

<p> int t, h, e;<p> 

<p> for (h=1; h<n; h++)<p> 

<p> {<p> 

<p> for(e=0; e<n;e++)<p> 
<p> {<p> 
<p> if (v[e]>v[e+1])<p> 
<p> {<p> 
<p> v[e+1] = t;<p> 
<p> v[e] = v[e+1];<p> 
<p> t= v[e];<p> 
<p> }<p> 
<p> }<p> 
<p> }<p> 
<p> }<p> 
<p> void ImprimirVector(float v[], int n)<p> 
<p> {<p> 
<p> int i; <p> 
<p> for (i=0; i<n; i++)<p> 
<p> {<p> 
<p> printf("%f ", v[i]);<p> 
<p> }<p> 
<p> }<p> 
<p> int main(int argc, char *argv[])<p> 
<p> {<p> 
<p> if(strcmp(argv[1], "burbuja")==0)<p> 
<p> {<p> 
<p> int n, i, m=2, o;<p> 
<p> float *v;<p> 
<p> {<p> 
<p> n=argc-2; <p> 
<p> v =(float *)malloc(n*sizeof(float));<p> 
<p> for (i=0; i<n; i++)<p> 
<p> {<p> 
<p> v[i] = atof(argv[i+2]);<p> 
<p> }<p> 
<p> }<p> 
<p> OrdenaBurbuja(v, n);<p> 
<p> ImprimirVector(v, n);<p> 
<p> }<p> 
<p> system("PAUSE"); <p> 
<p> return 0;<p> 
<p> }<p> 

           </script></div>
	      </article>
		  <article class="contenido">
		    
		  
		  
</section>
 
<aside>
<a class="twitter-timeline" data-width="300" data-height="600" href="https://twitter.com/UniversidadUNAD?ref_src=twsrc%5Etfw">Tweets by UniversidadUNAD</a> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
		</aside>

		<footer>
			<p>Universidad Nacional Abierta y a Distancia - UNAD</p>
			<p>Educación y Desarrollo "Mención de honor" En esta emisión continuamos con el reconocimiento a Jorge Reynolds Pombo, ingeniero y científico colombiano que ha dedicado su vida a estudiar el funcionamiento del corazón</p>
			
             <div class="info_sede div">
                <p> 
                </p>
            </div>
			<p></p>
			<p></p>
			<p>2018</p>
		</footer>	


</body>
</html>